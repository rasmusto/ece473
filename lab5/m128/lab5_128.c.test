// lab5_code.c 
// A. Condrea
// 9.12.08
// Lab Time: Wednesday 11-2

#define F_CPU 16000000 // cpu speed in hertz 
#define TRUE 1
#define FALSE 0
#define MAX_CHECKS 10      // # checks before a switch is debounced
#define DELAY .5
#define snoozeseconds 10
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <util/twi.h>
#include "music.c"
#define mute 0x04
#define unmute 0xFB
#define ALARM_PIN 0x80
#define NUM_SONGS 4
//LM73 Addresses on the I2C bus
//Using LM73-0, address pin floating (datasheet pg. 9)
#define LM73_ADDRESS 0x90
#define LM73_WRITE (LM73_ADDRESS | TW_WRITE) //LSB is a zero to write
#define LM73_READ (LM73_ADDRESS | TW_READ) //LSB is a one to read
//define the codes for actions to occur
#define TWCR_START 0xA4 //send start condition
#define TWCR_STOP   0x94 //send stop condition
#define TWCR_RACK   0xC4 //receive byte and return ack to slave
#define TWCR_RNACK 0x84 //receive byte and return  nack to slave
#define TWCR_SEND   0x84 //pokes the TWINT flag in TWCR and TWEN
#define LM73_PTR_TEMP         0x00  //LM73 temperature address
#define LM73_PTR_CONFIG       0x01  //LM73 configuration address
#define LM73_PTR_CTRL_STATUS  0x04  //LM73 ctrl and stat register

volatile uint8_t song;

//function prototypes defined here
void song0(uint16_t note); //Beaver Fight Song
void song1(uint16_t note); //Tetris Theme (A)
void song2(uint16_t note); //Mario Bros Theme
void song3(uint16_t note); 
void play_song(uint8_t song, uint8_t note);
void play_rest(uint8_t duration);
void play_note(char note, uint8_t flat, uint8_t octave, uint8_t duration);
void music_off(void);
void music_on(void);      
void music_init(void);

#define C0 0x1DDC
#define Db0 0x1C30
#define D0 0x1A9A
#define Eb0 0x1919
#define E0 0x17B2
#define F0 0x165D
#define Gb0 0x151D
#define G0 0x13ED
#define Ab0 0x12CE
#define A0 0x11C0
#define Bb0 0x10C0
#define B0 0x0FD0
#define C1 0x0EED
#define Db1 0x0E16
#define D1 0x0D4C
#define Eb1 0x0C8D
#define E1 0x0BD8
#define F1 0x0B2E
#define Gb1 0x0A8D
#define G1 0x09F6
#define Ab1 0x0967
#define A1 0x08DF
#define Bb1 0x0860
#define B1 0x07E7
#define C2 0x0776
#define Db2 0x070A
#define D2 0x06A5
#define Eb2 0x0646
#define E2 0x05EB
#define F2 0x0596
#define Gb2 0x0546
#define G2 0x04FA
#define Ab2 0x04B2
#define A2 0x046F
#define Bb2 0x042F
#define B2 0x03F3
#define C3 0x03BA
#define Db3 0x0384
#define D3 0x0352
#define Eb3 0x0322
#define E3 0x02F5
#define F3 0x02CA
#define Gb3 0x02A2
#define G3 0x027C
#define Ab3 0x0258
#define A3 0x0237
#define Bb3 0x0217
#define B3 0x01F9
#define C4 0x01DC
#define Db4 0x01C1
#define D4 0x01A8
#define Eb4 0x0190
#define E4 0x017A
#define F4 0x0164
#define Gb4 0x0150
#define G4 0x013D
#define Ab4 0x012B
#define A4 0x011B
#define Bb4 0x010B
#define B4 0x00FC
#define C5 0x00ED
#define Db5 0x00E0
#define D5 0x00D3
#define Eb5 0x00C7
#define E5 0x00BC
#define F5 0x00B1
#define Gb5 0x00A7
#define G5 0x009E
#define Ab5 0x0095
#define A5 0x008D
#define Bb5 0x0085
#define B5 0x007D
#define C6 0x0076
#define Db6 0x006F
#define D6 0x0069
#define Eb6 0x0063
#define E6 0x005D
#define F6 0x0058
#define Gb6 0x0053
#define G6 0x004E
#define Ab6 0x004A
#define A6 0x0046
#define Bb6 0x0042
#define B6 0x003E
#define C7 0x003A
#define Db7 0x0037
#define D7 0x0034
#define Eb7 0x0031
#define E7 0x002E
#define F7 0x002B
#define Gb7 0x0029
#define G7 0x0026
#define Ab7 0x0024
#define A7 0x0022
#define Bb7 0x0020
#define B7 0x001E
#define C8 0x001C
#define Db8 0x001B
#define D8 0x0019
#define Eb8 0x0018
#define E8 0x0015
#define F8 0x0012
#define Gb8 0x0010
#define G8 0x000D
#define Ab8 0x000B
#define A8 0x0009
#define Bb8 0x0007
#define B8 0x0005

volatile uint16_t beat;
volatile uint16_t max_beat;
volatile uint8_t  notes;

//holds data to be sent to the segments. logic zero turns segment on
volatile uint8_t segment_data[5];
//decimal to 7-segment LED display encodings, logic "0" turns on segment
volatile uint8_t dec_to_7seg[12]; 
//holds the decimal number associated with the display unit and sets it to 0
volatile uint16_t disp_value;
volatile uint8_t Debounced_State;   // Debounced state of the switches
volatile uint8_t State[MAX_CHECKS]; // Array that maintains bounce status
volatile uint8_t Index;             // Pointer into State
volatile uint8_t encoder_data;	   // Holds raw data from HC165
volatile uint8_t increment_value=1; // Value of increment/decrement step size for encoders
volatile uint8_t button1=0;	   // State of first button
volatile uint8_t button2=0;	   // State of second button
volatile uint8_t button3=0;
volatile uint8_t encoder1;	   // Encoder one value, reduced to two bits
volatile uint8_t encoder2;	   // Encoder two value, reduced to two bits
volatile uint8_t bargraph;	   // State of bargraph display
volatile uint8_t colon=1;	   // Colon state
volatile uint8_t sec=0;		   // Seconds value
volatile uint8_t min=0;		   // Minutes value
volatile uint8_t hour=12;	   // Hour value
volatile uint8_t amin=0;	   // Alarm minute value
volatile uint8_t ahour=12;	   // Alarm hour value
volatile int count=0;		   // Count value for ISR
volatile uint8_t timeset;	   // Time set flag
volatile uint8_t alarmset;	   // Alarm set flag
volatile uint16_t time;
volatile uint16_t alarm;
volatile uint8_t alarm_on=0;
volatile uint8_t pm=01;
volatile uint8_t alarm_pm=1;
volatile char lcd_adc[11];
volatile uint8_t snooze=0;
volatile uint16_t snooze1=0;
volatile uint16_t snooze2=snoozeseconds;
volatile uint8_t alarm_status=0;
volatile uint16_t adc_result;
volatile uint16_t dimming_value;
volatile uint8_t musicflag;
volatile uint8_t songchoice;
uint8_t indoor1=0;
uint8_t indoor2=0;

void song0(uint16_t note) { //beaver fight song (Max and Kellen)
  switch (note) {
    case 0: play_note('F', 0, 4, 8);
       break;
    case 1: play_note('E', 0, 4, 8);
       break;
    case 2: play_note('D', 0, 4, 8);
       break;
    case 3: play_note('C', 0, 4, 8);
       break;
    case 4: play_note('A', 0, 4, 6);
       break;
    case 5: play_note('A', 1, 4, 2);
       break;
    case 6: play_note('A', 0, 4, 6);
       break;
    case 7: play_note('A', 1, 4, 2);
       break;
    case 8: play_note('A', 0, 4, 16);
       break;
    case 9: play_note('F', 0, 4, 8);
       break;
    case 10: play_note('E', 0, 4, 8);
       break;
    case 11: play_note('D', 0, 4, 8);
       break;
    case 12: play_note('C', 0, 4, 8);
       break;
    case 13: play_note('B', 1, 4, 6);
       break;
    case 14: play_note('A', 0, 4, 2);
       break;
    case 15: play_note('B', 1, 4, 6);
       break;
    case 16: play_note('A', 0, 4, 2);
       break;
    case 17: play_note('B', 1, 4, 16);
       break;
    case 18: play_note('G', 0, 4, 3);
       break;
    case 19: play_rest(1); //rest
       break;
    case 20: play_note('G', 0, 4, 7);
       break;
    case 21: play_rest(1); //rest
       break;
    case 22: play_note('G', 1, 4, 4);
       break;
    case 23: play_note('G', 0, 4, 6);
       break;
    case 24: play_note('A', 0, 4, 2);
       break;
    case 25: play_note('B', 1, 4, 8);
       break;
    case 26: play_note('A', 0, 4, 2);
       break;
    case 27: play_rest(2); 
       break;
    case 28: play_note('A', 0, 4, 8);
       break;
    case 29: play_note('A', 1, 4, 4);
       break;
    case 30: play_note('A', 0, 4, 6);
       break;
    case 31: play_note('B', 1, 4, 2);
       break;
    case 32: play_note('C', 0, 5, 4);
       break;
    case 33: play_note('D', 1, 5, 4);
       break;
    case 34: play_note('D', 0, 5, 4);
       break;
    case 35: play_note('B', 0, 4, 8);
       break;
    case 36: play_note('A', 0, 4, 4);
       break;
    case 37: play_note('G', 0, 4, 8);
       break;
    case 38: play_note('A', 0, 4, 8);
       break;
    case 39: play_note('G', 0, 4, 24);
       break;
    case 40: play_rest(8);
       break;
    case 41: play_note('F', 0, 4, 8);
       break;
    case 42: play_note('E', 0, 4, 8);
       break;
    case 43: play_note('D', 0, 4, 8);
       break;
    case 44: play_note('C', 0, 4, 8);
       break;
    case 45: play_note('A', 0, 4, 6);
       break;
    case 46: play_note('A', 1, 4, 2);
       break;
    case 47: play_note('A', 0, 4, 6);
       break;
    case 48: play_note('A', 1, 4, 2);
       break;
    case 49: play_note('A', 0, 4, 16);
       break;
    case 50: play_note('F', 0, 4, 8);
       break;
    case 51: play_note('G', 1, 4, 8);
       break;
    case 52: play_note('G', 0, 4, 8);
       break;
    case 53: play_note('D', 0, 4, 8);
       break;
    case 54: play_note('B', 1, 4, 6);
       break;
    case 55: play_note('A', 0, 4, 2);
       break;
    case 56: play_note('B', 1, 4, 6);
       break;
    case 57: play_note('A', 0, 4, 2);
       break;
    case 58: play_note('B', 1, 4, 16);
      break;//phrase
    case 59: play_note('D', 0, 4, 16);
       break;
    case 60: play_note('D', 0, 5, 16);
       break;
    case 61: play_note('A', 0, 4, 16);
       break;
    case 62: play_note('C', 0, 5, 16);
       break;
    case 63: play_note('B', 1, 4, 8);
       break;
    case 64: play_note('C', 0, 5, 4);
       break;
    case 65: play_note('D', 0, 5, 4);
       break;
    case 66: play_note('A', 0, 4, 8);
       break;
    case 67: play_note('G', 0, 4, 8);
       break;
    case 68: play_note('F', 0, 4, 24);
       break;
    case 69: play_rest(8);
       break;
    default: notes=-1;
  }
}//song0

void song1(uint16_t note) { //tetris theme (Kellen)
switch (note) {
    case 0: play_note('E', 0, 4, 8);
       break;
    case 1: play_note('B', 0, 3, 4);
       break;
    case 2: play_note('C', 0, 4, 4);
       break;
    case 3: play_note('D', 0, 4, 4);
       break;
    case 4: play_note('E', 0, 4, 2);
       break;
    case 5: play_note('D', 0, 4, 2);
       break;
    case 6: play_note('C', 0, 4, 4);
       break;
    case 7: play_note('B', 0, 3, 4);
       break;//bar
    case 8: play_note('A', 0, 3, 7);
       break;
    case 9: play_rest(1);
       break;
    case 10: play_note('A', 0, 3, 4);
       break;
    case 11: play_note('C', 0, 4, 4);
       break;
    case 12: play_note('E', 0, 4, 8);
       break;
    case 13: play_note('D', 0, 4, 4);
       break;
    case 14: play_note('C', 0, 4, 4);
       break;//bar
    case 15: play_note('B', 0, 3, 12);
       break;
    case 16: play_note('C', 0, 4, 4);
       break;
    case 17: play_note('D', 0, 4, 8);
       break;
    case 18: play_note('E', 0, 4, 8);
       break;//bar
    case 19: play_note('C', 0, 4, 8);
       break;
    case 20: play_note('A', 0, 3, 7);
       break;
    case 21: play_rest(1);
       break;
    case 22: play_note('A', 0, 3, 16);
       break;//bar phrase
    case 23: play_rest(4);
       break;
    case 24: play_note('D', 0, 4, 8);
        break;
    case 25: play_note('F', 0, 4, 4);
       break;
    case 26: play_note('A', 0, 4, 8);
       break;
    case 27: play_note('G', 0, 4, 4);
       break;
    case 28: play_note('F', 0, 4, 4);
       break;//bar
    case 29: play_note('E', 0, 4, 12);
        break;
    case 30: play_note('C', 0, 4, 4);
       break;
    case 31: play_note('E', 0, 4, 8);
        break;
    case 32: play_note('D', 0, 4, 4);
       break;
    case 33: play_note('C', 0, 4, 4);
       break;//bar
    case 34: play_note('B', 0, 3, 7);
       break;
    case 35: play_rest(1);
        break;
    case 36: play_note('B', 0, 3, 4);
       break;
    case 37: play_note('C', 0, 4, 4);
       break;
    case 38: play_note('D', 0, 4, 8);
       break;
    case 39: play_note('E', 0, 4, 8);
       break;
    case 40: play_note('C', 0, 4, 8);
       break;
    case 41: play_note('A', 0, 3, 7);
       break;
    case 42: play_rest(1);
       break;
    case 43: play_note('A', 0, 3, 8);
       break;
    case 44: play_rest(8);
       break;//bar phrase
    case 45: play_note('E', 0, 3, 16);
       break;
    case 46: play_note('C', 0, 3, 16);
       break;//bar
    case 47: play_note('D', 0, 3, 16);
       break;
    case 48: play_note('B', 0, 2, 16);
       break;//bar
    case 49: play_note('C', 0, 3, 16);
       break;
    case 50: play_note('A', 0, 2, 16);
       break;//bar
    case 51: play_note('A', 1, 2, 16);
       break;
    case 52: play_note('B', 0, 2, 8);
       break;
    case 53: play_rest(8);
       break;//bar phrase
    case 54: play_note('E', 0, 3, 16);
       break;
    case 55: play_note('C', 0, 3, 16);
       break;//bar
    case 56: play_note('D', 0, 3, 16);
       break;
    case 57: play_note('B', 0, 2, 16);
       break;//bar
    case 58: play_note('C', 0, 3, 8);
       break;
    case 59: play_note('E', 0, 3, 8);
       break;
    case 60: play_note('A', 0, 3, 16);
       break;//bar
    case 61: play_note('A', 1, 3, 16);
       break;
    case 62: play_rest(16);
      break;//bar phrase
    default: notes=-1;

 }
}//song1

void song2(uint16_t note) { //Super Mario Bros Theme (Brian)
switch (note) {
    case 0: play_note('E', 0, 4, 1);
       break;
    case 1: play_rest(1);
       break;
    case 2: play_note('E', 0, 4, 3);
       break;
    case 3: play_rest(1);
       break;
    case 4: play_note('E', 0, 4, 2);
       break;
    case 5: play_rest(2);
       break;
    case 6: play_note('C', 0, 4, 2);
       break;
    case 7: play_note('E', 0, 4, 4);
       break;
    case 8: play_note('G', 0, 4, 8);
       break;
    case 9: play_note('G', 0, 2, 8);
       break;
    case 10: play_rest(8);
       break;
    case 11: play_note('C', 0, 4, 5);
       break;
    case 12: play_note('G', 0, 3, 2);
       break;
    case 13: play_rest(4);
       break;
    case 14: play_note('E', 0, 3, 4);
       break;
    case 15: play_rest(2);
       break;
    case 16: play_note('A', 0, 3, 2);
       break;
    case 17: play_rest(2);
         break;
    case 18: play_note('B', 0, 3, 2);
       break;
    case 19: play_rest(2);
       break;
    case 20: play_note('B', 1, 3, 2);
       break;
    case 21: play_note('A', 0, 3, 4);
       break;
    case 22: play_note('G' , 0, 3, 3);
       break;
    case 23: play_note('E', 0, 4, 2);
       break;
    case 24: play_rest(1);
        break;
    case 25: play_note('G', 0, 4, 2);
       break;
    case 26: play_note('A', 0, 4, 4);
       break;
    case 27: play_note('F', 0, 4, 2);
       break;
    case 28: play_note('G', 0, 4, 2);
       break;
    case 29: play_rest(2);
        break;
    case 30: play_note('E', 0, 4, 2);
       break;
    case 31: play_rest(2);
        break;
    case 32: play_note('C', 0, 4, 2);
       break;
    case 33: play_note('D', 0, 4, 2);
       break;
    case 34: play_note('B', 0, 3, 2);
       break;
    case 35: play_rest(4);
        break;
    case 36: play_note('C', 0, 4, 5);
       break;
    case 37: play_rest(2);
       break;
    case 38: play_note('G', 0, 3, 2);
       break;
    case 39: play_rest(3);
       break;
    case 40: play_note('E', 0, 3, 4);
       break;
    case 41: play_rest(2);
       break;
    case 42: play_note('A', 0, 3, 2);
       break;
    case 43: play_rest(2);
         break;
    case 44: play_note('B', 0, 3, 2);
       break;
    case 45: play_rest(2);
       break;
    case 46: play_note('B', 1, 3, 2);
       break;
    case 47: play_note('A', 0, 3, 4); //phrase
       break;
    case 48: play_note('G' , 0, 3, 3);
       break;
    case 49: play_note('E', 0, 4, 2);
       break;
    case 50: play_rest(1);
        break;
    case 51: play_note('G', 0, 4, 2);
       break;
    case 52: play_note('A', 0, 4, 4);
       break;
    case 53: play_note('F', 0, 4, 2);
       break;
    case 54: play_note('G', 0, 4, 2);
       break;
    case 55: play_rest(2);
        break;
    case 56: play_note('E', 0, 4, 2);
       break;
    case 57: play_rest(2);
        break;
    case 58: play_note('C', 0, 4, 2);
       break;
    case 59: play_note('D', 0, 4, 2);
       break;
    case 60: play_note('B', 0, 3, 2);
       break;
    case 61: play_rest(8);
       break;
    case 62: play_note('G', 0, 4, 2);
       break;
    case 63: play_note('G', 1, 4, 2);
       break;
    case 64: play_note('F', 0, 4, 2);
       break;
    case 65: play_note('E', 1, 4, 2);
       break;
    case 66: play_rest(2);
       break;
    case 67: play_note('E', 0, 4, 2);
       break;
    case 68: play_rest(2);
       break;
    case 69: play_note('A', 1, 3, 2);
       break;
    case 70: play_note('A', 0, 3, 2);
       break;
    case 71: play_note('C', 0, 4, 2);
       break;
    case 72: play_rest(2);
       break;
    case 73: play_note('A', 0, 3, 2);
       break;
    case 74: play_note('C', 0, 4, 2);
       break;
    case 75: play_note('D', 0, 4, 2);
       break;
    case 76: play_rest(4);
       break;
    case 77: play_note('G', 0, 3, 2);
       break;
    case 78: play_note('G', 1, 3, 2);
       break;
    case 79: play_note('F', 0, 3, 2);
       break;
    case 80: play_note('E', 1, 3, 2);
       break;
    case 81: play_rest(2);
       break;
    case 82: play_note('E', 0, 3, 2);
       break;
    case 83: play_rest(2);
       break;
    case 84: play_note('G', 0, 4, 2);
       break;
    case 85: play_rest(2);
       break;
    case 86: play_note('G', 0, 4, 1);
       break;
    case 87: play_rest(1);
       break;
    case 88: play_note('G', 0, 4, 4);
       break;
    case 89: play_rest(8);
       break;
    case 90: play_note('G', 0, 4, 2);
       break;
    case 91: play_note('G', 1, 4, 2);
       break;
    case 92: play_note('F', 0, 4, 2);
       break;
    case 93: play_note('E', 1, 4, 2);
       break;
    case 94: play_rest(2);
       break;
    case 95: play_note('E', 0, 4, 2);
       break;
    case 96: play_rest(2);
       break;
    case 97: play_note('A', 1, 3, 2);
       break;
    case 98: play_note('A', 0, 3, 2);
       break;
    case 99: play_note('C', 0, 4, 2);
       break;
    case 100: play_rest(2);
       break;
    case 101: play_note('A', 0, 3, 2);
       break;
    case 102: play_note('C', 0, 4, 2);
       break;
    case 103: play_note('D', 0, 4, 2);
       break;
    case 104: play_rest(4);
       break;
    case 105: play_note('E', 1, 4, 4);
       break;
    case 106: play_rest(2);
       break;
    case 107: play_note('D', 0, 4, 2);
       break;
    case 108: play_rest(4);
        break;
    case 109: play_note('C', 0, 4, 4);
       break;
    case 110: play_rest(10);
       break;
    case 111: play_note('C', 0, 4, 2);
       break;
    case 112: play_rest(1);
       break;
    case 113: play_note('C', 0, 4, 2);
        break;
    case 114: play_rest(2);
        break;
    case 115: play_note('C', 0, 4, 2);
        break;
    case 116: play_rest(2);
        break;
    case 117: play_note('C', 0, 4, 2);
        break;
    case 118: play_note('D', 0, 4, 4);
        break;
    case 119: play_note('E', 0, 4, 2);
        break;
    case 120: play_note('C', 0, 4, 2);
        break;
    case 121: play_rest(2);
        break;
    case 122: play_note('A', 0, 3, 2);
        break;
    case 123: play_note('G', 0, 3, 4);
        break;
    case 124: play_rest(4);
       break;
    case 125: play_note('C', 0, 4, 2);
       break;
    case 126: play_rest(1);
       break;
    case 127: play_note('C', 0, 4, 2);
        break;
    case 128: play_rest(2);
        break;
    case 129: play_note('C', 0, 4, 2);
        break;
    case 130: play_rest(2);
        break;
    case 131: play_note('C', 0, 4, 2);
        break;
    case 132: play_note('D', 0, 4, 2);
        break;
    case 133: play_note('E', 0, 4, 2);
        break;
    case 134: play_rest(16);
        break;
    case 135: play_note('C', 0, 4, 2);
        break;
    case 136: play_rest(1);
        break;
    case 137: play_note('C', 0, 4, 2);
        break;
    case 138: play_rest(2);
        break;
    case 139: play_note('C', 0, 4, 2);
        break;
    case 140: play_rest(2);
        break;
    case 141: play_note('C', 0, 4, 2);
        break;
    case 142: play_note('D', 0, 4, 4);
        break;
    case 143: play_note('E', 0, 4, 2);
        break;
    case 144: play_note('C', 0, 4, 2);
        break;
    case 145: play_rest(2);
        break;
    case 146: play_note('A', 0, 3, 2);
        break;
    case 147: play_note('G', 0, 3, 4);
	break;
    case 148: play_rest(8);
        break;
    default: notes=-1;

 }
}//song2

void song3(uint16_t note) { //(Max and Kellen)
  switch (note) {
    case 0: play_note('E', 0, 4, 7);
       break;
    case 1: play_rest(1);
       break;
    case 2: play_note('E', 0, 4, 7);
       break;
    case 3: play_rest(1);
       break;
    case 4: play_note('E', 0, 4, 7);
       break;
    case 5: play_rest(1);
       break;
    case 6: play_note('E', 0, 4, 3);
       break;
    case 7: play_rest(1);
       break;
    case 8: play_note('E', 0, 4, 3);
       break;
    case 9: play_rest(5);
       break;
    case 10: play_note('E', 0, 5, 4);
       break;
    case 11: play_note('G', 1, 5, 4);
       break;
    case 12: play_note('E', 0, 5, 4);
       break;
    case 13: play_note('G', 0, 5, 8);
       break;
    case 14: play_note('E', 0, 5, 8);
       break;
       //phrase
    case 15: play_note('E', 1, 4, 7);
       break;
    case 16: play_rest(1);
       break;
    case 17: play_note('E', 1, 4, 7);
       break;
    case 18: play_rest(1);
       break;
    case 19: play_note('E', 1, 4, 7);
       break;
    case 20: play_rest(1);
       break;
    case 21: play_note('E', 1, 4, 3);
       break;
    case 22: play_rest(1);
       break;
    case 23: play_note('E', 1, 4, 3);
       break;
    case 24: play_rest(5);
       break;
    case 25: play_note('E', 1, 5, 4);
       break;
    case 26: play_note('E', 0, 5, 3);
       break;
    case 27: play_rest(1); //rest 1
       break;
    case 28: play_note('E', 0, 5, 4);
       break;
    case 29: play_note('G', 1, 5, 8);
       break;
    case 30: play_note('E', 0, 5, 8);
       break;
    default: notes=-1;
  }
}//song3

void play_song(uint8_t song, uint8_t note) {
  //if you add a song, you'll have to add it to this
  //switch statement.
  switch (song) {
  case 0: song0(note); //beaver fight song
    break;
  case 1: song1(note); //tetris theme
    break;
  case 2: song2(note); //super mario bros
    break;
  case 3: song3(note);
    break;
  default: song0(note); //defaults to beaver fight song
  }
}

void play_rest(uint8_t duration) {
  //mute for duration
  //duration is in 64th notes at 120bpm
  PORTD |= 0x04;
  beat=0;
  max_beat = duration;
}

void play_note(char note, uint8_t flat, uint8_t octave, uint8_t duration) {
  //pass in the note, it's key, the octave they want, and a duration
  //function sets the value of OCR1A and the timer
  //note must be A-G
  //flat must be 1 (for flat) or 0 (for natural) (N/A on C or F)
  //octave must be 0-8 (0 is the lowest, 8 doesn't sound very good)
  //duration is in 64th notes at 120bpm
  //e.g. play_note('D', 1, 0, 16)
  //this would play a Db, octave 0 for 1 quarter note
  //120 bpm (every 32ms inc beat)
  PORTD &= 0xFB;      //unmute (just in case)
  beat = 0;             //reset the beat counter
  max_beat = duration;  //set the max beat
  switch (octave) {
    case 0: switch (note) {
      case 'A': if(flat){OCR1A=Ab0;}
        else {OCR1A=A0;}
	break;
      case 'B': if(flat){OCR1A=Bb0;}
        else {OCR1A=B0;}
	break;
      case 'C': OCR1A=C0;
	break;
      case 'D': if(flat){OCR1A=Db0;}
        else {OCR1A=D0;}
	break;
      case 'E': if(flat){OCR1A=Eb0;}
        else {OCR1A=E0;}
	break;
      case 'F': OCR1A=F0;
	break;
      case 'G': if(flat){OCR1A=Gb0;}
        else {OCR1A=G0;}
	break;
      } 
      break;
    case 1: switch (note) {
      case 'A': if(flat){OCR1A=Ab1;}
        else {OCR1A=A1;}
	break;
      case 'B': if(flat){OCR1A=Bb1;}
        else {OCR1A=B1;}
	break;
      case 'C': OCR1A=C1;
	break;
      case 'D': if(flat){OCR1A=Db1;}
        else {OCR1A=D1;}
	break;
      case 'E': if(flat){OCR1A=Eb1;}
        else {OCR1A=E1;}
	break;
      case 'F': OCR1A=F1;
	break;
      case 'G': if(flat){OCR1A=Gb1;}
        else {OCR1A=G1;}
	break;
      } 
      break;
    case 2: switch (note) {
      case 'A': if(flat){OCR1A=Ab2;}
        else {OCR1A=A2;}
	break;
      case 'B': if(flat){OCR1A=Bb2;}
        else {OCR1A=B2;}
	break;
      case 'C': OCR1A=C2;
	break;
      case 'D': if(flat){OCR1A=Db2;}
        else {OCR1A=D2;}
	break;
      case 'E': if(flat){OCR1A=Eb2;}
        else {OCR1A=E2;}
	break;
      case 'F': OCR1A=F2;
	break;
      case 'G': if(flat){OCR1A=Gb2;}
        else {OCR1A=G2;}
	break;
      } 
      break;
    case 3: switch (note) {
      case 'A': if(flat){OCR1A=Ab3;}
        else {OCR1A=A3;}
	break;
      case 'B': if(flat){OCR1A=Bb3;}
        else {OCR1A=B3;}
	break;
      case 'C': OCR1A=C3;
	break;
      case 'D': if(flat){OCR1A=Db3;}
        else {OCR1A=D3;}
	break;
      case 'E': if(flat){OCR1A=Eb3;}
        else {OCR1A=E3;}
	break;
      case 'F': OCR1A=F3;
	break;
      case 'G': if(flat){OCR1A=Gb3;}
        else {OCR1A=G3;}
	break;
      } 
      break;
    case 4: switch (note) {
      case 'A': if(flat){OCR1A=Ab4;}
        else {OCR1A=A4;}
	break;
      case 'B': if(flat){OCR1A=Bb4;}
        else {OCR1A=B4;}
	break;
      case 'C': OCR1A=C4;
	break;
      case 'D': if(flat){OCR1A=Db4;}
        else {OCR1A=D4;}
	break;
      case 'E': if(flat){OCR1A=Eb4;}
        else {OCR1A=E4;}
	break;
      case 'F': OCR1A=F4;
	break;
      case 'G': if(flat){OCR1A=Gb4;}
        else {OCR1A=G4;}
	break;
      } 
      break;
    case 5: switch (note) {
      case 'A': if(flat){OCR1A=Ab5;}
        else {OCR1A=A5;}
	break;
      case 'B': if(flat){OCR1A=Bb5;}
        else {OCR1A=B5;}
	break;
      case 'C': OCR1A=C5;
	break;
      case 'D': if(flat){OCR1A=Db5;}
        else {OCR1A=D5;}
	break;
      case 'E': if(flat){OCR1A=Eb5;}
        else {OCR1A=E5;}
	break;
      case 'F': OCR1A=F5;
	break;
      case 'G': if(flat){OCR1A=Gb5;}
        else {OCR1A=G5;}
	break;
      } 
      break;
    case 6: switch (note) {
      case 'A': if(flat){OCR1A=Ab6;}
        else {OCR1A=A6;}
	break;
      case 'B': if(flat){OCR1A=Bb6;}
        else {OCR1A=B6;}
	break;
      case 'C': OCR1A=C6;
	break;
      case 'D': if(flat){OCR1A=Db6;}
        else {OCR1A=D6;}
	break;
      case 'E': if(flat){OCR1A=Eb6;}
        else {OCR1A=E6;}
	break;
      case 'F': OCR1A=F6;
	break;
      case 'G': if(flat){OCR1A=Gb6;}
        else {OCR1A=G6;}
	break;
      } 
      break;
    case 7: switch (note) {
      case 'A': if(flat){OCR1A=Ab7;}
        else {OCR1A=A7;}
	break;
      case 'B': if(flat){OCR1A=Bb7;}
        else {OCR1A=B7;}
	break;
      case 'C': OCR1A=C7;
	break;
      case 'D': if(flat){OCR1A=Db7;}
        else {OCR1A=D7;}
	break;
      case 'E': if(flat){OCR1A=Eb7;}
        else {OCR1A=E7;}
	break;
      case 'F': OCR1A=F7;
	break;
      case 'G': if(flat){OCR1A=Gb7;}
        else {OCR1A=G7;}
	break;
      } 
      break;
    case 8: switch (note) {
      case 'A': if(flat){OCR1A=Ab8;}
        else {OCR1A=A8;}
	break;
      case 'B': if(flat){OCR1A=Bb8;}
        else {OCR1A=B8;}
	break;
      case 'C': OCR1A=C8;
	break;
      case 'D': if(flat){OCR1A=Db8;}
        else {OCR1A=D8;}
	break;
      case 'E': if(flat){OCR1A=Eb8;}
        else {OCR1A=E8;}
	break;
      case 'F': OCR1A=F8;
	break;
      case 'G': if(flat){OCR1A=Gb8;}
        else {OCR1A=G8;}
	break;
      } 
      break;
    default: OCR1A=0x0000;
  }
}

void music_off(void) {
  //this turns the alarm timer off
  notes=0;
  TCCR1B &= ~((1<<CS11)|(1<<CS10));
  //and mutes the output
  PORTD |= 0x04;
}

void music_on(void) {
  //this starts the alarm timer running
    if(musicflag=1){
  notes=0;
  TCCR1B |= (1<<CS11)|(1<<CS10);
  //unmutes the output
  PORTD &= 0xFB;
  //and starts the selected song
  play_song(song, notes);
}}

void music_init(void) {
  //initially turned off (use music_on() to turn on)
  TIMSK |= (1<<OCIE1A);  //enable timer interrupt 1 on compare
  TCCR1A = 0x00;         //TCNT1, normal port operation
  TCCR1B |= (1<<WGM12);  //CTC, OCR1A = top, clk/64 (250kHz)
  TCCR1C = 0x00;         //no forced compare
  OCR1A = 0x0031;        //(use to vary alarm frequency)
  music_off();
  beat = 0;
  max_beat = 0;
  notes = 0;
  //song = 1;              //beaver fight song
} 

/*********************************************************************/
/*                             TIMER1_COMPA                          */
/*Oscillates pin7, PORTD for alarm tone output                       */
/*********************************************************************/

ISR(TIMER1_COMPA_vect) {
  PORTD ^= ALARM_PIN;      //flips the bit, creating a tone
  if(beat >= max_beat) {   //if we've played the note long enough
    notes++;               //move on to the next note
    play_song(song, notes);//and play it
  }
}

//******************************************************************************
//                            chk_buttons                                      
//Checks the state of the button number passed to it. It shifts in ones till   
//the button is pushed. Function returns a 1 only once per debounced button    
//push so a debounce and toggle function can be implemented at the same time.  
//Adapted to check all buttons from Ganssel's "Guide to Debouncing"            
//Expects active low pushbuttons on PINA port.  Debounce time is determined by 
//external loop delay times 12. 
//
uint8_t chk_buttons(uint8_t button) {
	static uint16_t  state[8] = {0,0,0,0,0,0,0,0};  //holds present state  
	state[button] = (state[button] << 1) | (! bit_is_clear(PINA, button)) | 0xE000;
	if (state[button] == 0xF000) return 1;
	return 0;
}
//******************************************************************************

//***********************************************************************************
//                                   segment_sum                                    
//takes a 16-bit binary input value and places the appropriate equivalent 4 digit 
//BCD segment code in the array segment_data for display.                       
//array is loaded at exit as:  |digit3|digit2|colon|digit1|digit0|
//***********************************************************************************	
void segsum(uint16_t sum) {
  //determine how many digits there are 
	uint8_t d,p,x,y,z,t;
	p = sum/10;
	if(p==0) {d=1;}
	else if(p<10){d=2;}
	else if(p<100){d=3;}
	else {d=4;}
  //break up decimal sum into 4 digit-segments
	x = sum%10;
	y = sum%100/10;
	z = sum%1000/100;
	t = sum%10000/1000;
  //now move data to right place for misplaced colon position
	dec_to_7seg[0]=0xC0;
	dec_to_7seg[1]=0xF9;
	dec_to_7seg[2]=0xA4;
	dec_to_7seg[3]=0xB0;
	dec_to_7seg[4]=0x99;
	dec_to_7seg[5]=0x92;
	dec_to_7seg[6]=0x82;
	dec_to_7seg[7]=0xF8;
	dec_to_7seg[8]=0x80;
	dec_to_7seg[9]=0x90;
	segment_data[0]=dec_to_7seg[x];
	segment_data[1]=dec_to_7seg[y];
	segment_data[3]=dec_to_7seg[z];
	segment_data[4]=dec_to_7seg[t];
  //blank out leading zero digits
	switch(d){
		case 1:
		segment_data[1]=0xFF;
		segment_data[2]=0xFF;
		segment_data[3]=0xFF;
		segment_data[4]=0xFF;
		break;
		case 2:
		segment_data[2]=0xFF;
		segment_data[3]=0xFF;
		segment_data[4]=0xFF;
		break;
		case 3:
		segment_data[4]=0xFF;
		break;
	}

	return;
}//segment_sum
//***********************************************************************************

//******************************************************************************
//				printscrn
// Refreshes the LED display with the appropriate values using the segment_sum
// and by setting which segment is refreshed with the appropriate value
//******************************************************************************
void printscrn(){
  //break up the disp_value to 4, BCD digits in the array: call (segsum)
    segsum(disp_value);
  //make PORTA an output
    DDRA = 0xFF;
  //send 7 segment code to LED segments
    PORTA=segment_data[0];
    PORTB = 0x0F; //push button selects segment
    _delay_ms(DELAY);
    PORTA=segment_data[1];
    PORTB = 0x1F; //push button selects segment
    _delay_ms(DELAY);
    PORTA=segment_data[2];
    if((colon==0 && pm==0)){
      PORTA = 0xFF;} // case: neither pm or colon are on
    if((colon==1 && pm==1 && alarmset==0) || (colon==1 && alarm_pm==1 && alarmset==1)){
      PORTA = 0x00;} //case: both pm and colon are on
    if((colon==0 && pm==1)){
      PORTA = 0x03;} //case: only pm on
    if((colon==1 && pm==0 && alarmset==0) || (colon==1 && alarm_pm==0 && alarmset==1)){
      PORTA = 0x04;} //case: only colon on
    PORTB = 0x2F; //push button selects segment
    _delay_ms(DELAY);
    PORTA=segment_data[3];
    PORTB = 0x3F; //push button selects segment
    _delay_ms(DELAY);
    PORTA=segment_data[4];
    PORTB = 0x4F; //push button selects segment
    _delay_ms(DELAY);
    PORTA = 0xFF;
}
//printscrn

//******************************************************************************
//				chkbuttons
//Compares the status of the buttons to conditions we would like to meet and executes
//changes in variables appropriately
//******************************************************************************
void chkbuttons(){
    //make PORTA an input port with pullups 
    DDRA = 0x00;
    PORTA = 0xFF;
    //enable tristate buffer for pushbutton switches
    PORTB = 0x5F;
    if(chk_buttons(6)){
      button1 ^= 0x01;}
    else if(chk_buttons(7)){
      button2 ^= 0x01;}
    else if(chk_buttons(5)){
      if(alarm_on==1){
      button3 ^= 0x01;}}
    else if(chk_buttons(4)){
      alarm_status ^= 0x01;
      snooze1=0;}
    else if(chk_buttons(3)){
      songchoice++;
      song=songchoice%4;
      spi_send(song);}
  if(button3 == 1){
    snooze = 1;
    alarm_on = 0;
    snooze1=0;
    button3=0;}
  if(button1==1&&button2==1&&snooze==0){
    timeset=0;
    alarmset=0;
    bargraph=0x03;}
  else if(button1==1&&button2==0&&snooze==0){
    alarmset=1;
    timeset=0;
    bargraph=0x02;}
  else if(button1==0&&button2==1&&snooze==0){
    alarmset=0;
    timeset=1;
    bargraph=0x01;}
  else if(button1==0&&button2==0&&snooze==0){
    alarmset=0;
    timeset=0;
    bargraph=0x00;}
  else if(button1==0&&button2==0&&snooze==1){
    alarmset=0;
    timeset=0;
    bargraph=0x04;}
  else if(button1==1&&button2==0&&snooze==1){
    alarmset=1;
    timeset=0;
    bargraph=0x05;}
  else if(button1==0&&button2==1&&snooze==1){
    alarmset=0;
    timeset=1;
    bargraph=0x06;}
  else if(button1==1&&button2==1&&snooze==1){
    alarmset=0;
    timeset=0;
    bargraph=0x07;}
}
//chkbuttons

//******************************************************************************
//				spi_init
// initializes the spi protocol
//******************************************************************************
void spi_init(void){
  DDRB = DDRB | 0x07;            //Turn on SS, MOSI, SCLK (SS is output)
  SPCR |= (1<<SPE) | (1<<MSTR); //spi enabled, master, low polarity, msb 1st
  SPSR |= (1<<SPI2X);            //run at i/o clock div 2
}
//spi_init

/***********************************************************************/
/*                                spi_send                               */
/* Sends command and data to the SPI port. SPI device chip select is */
/* active low and is connected to port F bit 2. 16 bits total sent.      */
/***********************************************************************/
void spi_send(uint8_t data){
   PORTB = 0x50; //port B bit 3, assert active low
   _delay_ms(.1);
   PORTB = 0x70;
   SPDR = 0x55;                        //send command byte (fixed value)
   while (bit_is_clear(SPSR,SPIF)) {} //wait till data is sent out
   encoder_data = SPDR;
   SPDR = data; //send data byte
   PORTB = 0x60;
   while (bit_is_clear(SPSR,SPIF)) {} //wait till data is sent out
   PORTB = 0x50;                      //port B bit 2, deassert to logic high
   encoder1 = encoder_data & 0x03;
   encoder2 = (encoder_data & 0x0C) / 4;
   DDRF |= 0x08;  //port F bit 3 is enable for LCD
   PORTB |= 0x00; //port B initalization for SPI
   DDRB |= 0x07;  //Turn on SS, MOSI, SCLK 
   //Master mode, Clock=clk/2, Cycle half phase, Low polarity, MSB first  
   SPCR = 0x50;
   SPSR = 0x01;
} 
//spi_send

//******************************************************************************
//				encoder_ping
// checks changes in encoder values and changes global variables appropriately to
//increment the display count by the increment value
//******************************************************************************
void encoder_ping(){
  switch(encoder1){
      case 0x00:
      	while(encoder1==0x00){
	spi_send(bargraph);
	chkbuttons();
	printscrn();
	dimming();
	_delay_ms(5);
	if(encoder2==0x00){
	  break;}
	}
	switch(encoder1){
	  case 0x02:
	  if(timeset==1){
	    if(hour!=1){
	      if(hour==12){
		pm^=0x01;}
	      hour--;}
	    else if(hour==1){
	      hour=12;}
	  }
	  if(alarmset==1){
	    if(ahour!=1){
	      if(ahour==12){
		alarm_pm^=0x01;}
	      ahour--;}
	    else if(ahour==1){
	      ahour=12;}
	  }
	  break;
	  case 0x01:
	  if(timeset==1){
	    if(hour==11){
	      pm^=0x01;}
	    hour++;}
	  if(alarmset==1){
	    if(ahour!=12){
	      if(ahour==11){
		alarm_pm^=0x01;}
	      ahour++;}
	    else if(ahour==12){
	      ahour=1;}
	  }
	}
	  break;
  }
      
  switch(encoder2){
      case 0x00:
      	while(encoder2==0x00){
	spi_send(bargraph);
	chkbuttons();
	printscrn();
	dimming();
	_delay_ms(5);
	if(encoder1==0x00){
	  break;}
	}
	switch(encoder2){   //printscrn();
	  case 0x02:
	  if(timeset==1){
	    if(min!=0){
	      min--;}
	    else if(min==0){
	      min=59;}
	  }
	  if(alarmset==1){
	    if(amin!=0){
	      amin--;}
	    else if(amin==0){
	      amin=59;}
	  }
	  break;
	  case 0x01:
	  if(timeset==1){
	    min++;
	  }
	  if(alarmset==1){
	    if(amin!=59){
	      amin++;}
	    else if(amin==59){
	      amin=0;}
	  }
	  break;
	}
      break;
  }
}
//ping_encoder

void dimming(){
    ADCSRA |= 0x40;                     //poke ADSC and start conversion
    while(bit_is_clear(ADCSRA, ADIF));  //spin while interrupt flag not set
    ADCSRA |= (1 << ADIF);              //its done, clear flag by writing a one
    adc_result = ADCW;                  //read the ADC output as 16 bits
    itoa(adc_result, lcd_adc, 10);      //convert a int to a string
    //home_line2();			//go to second line of lcd
    //string2lcd(lcd_adc);		//print adc value for calibration
    OCR2=2; 				//set duty cycle of pwm according to adc
    if(adc_result<200){
      OCR2=175;}
    else if(adc_result<300){
      OCR2=150;}
    else if(adc_result<380){
      OCR2=120;}
    //else if(adc_result<450){
    //OCR2=75;}
    else if(adc_result<500){
      OCR2=60;}
    else if(adc_result<600){
      OCR2=40;} 
    else if(adc_result<650){
      OCR2=30;}
    else if(adc_result<700){
      OCR2=25;}
    else if(adc_result<800){
      OCR2=20;}
    else if(adc_result<900){
      OCR2=16;}
    else if(adc_result<1000){
      OCR2=4;}
    if(alarmset==1 || timeset==1){
      OCR2=0xFF;} 
}
  
void twi_init(){
  TWBR=0x03;
  TWCR|=(1<<TWEN);
}

uint8_t rd_temp(){
	TWCR = TWCR_START; //send start condition
	while (!(TWCR & (1<<TWINT))); //wait for start condition to transmit
	if((TWSR & 0xF8) != TW_START){
		string2lcd("ERROR1"); //check start status
	}
	TWDR = LM73_READ; //send device addr, read bit set
	TWCR = (1<<TWINT)|(1<<TWEN);
	while (!(TWCR & (1<<TWINT)));
	if((TWSR & 0xf8) != TW_MR_SLA_ACK){
		string2lcd("ERROR2");
	}
	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);//enable TWI and ACK
	while(!(TWCR & (1<<TWINT)));
	indoor1= TWDR;//assign byte read to variable
	if((TWSR & 0xF8) != TW_MR_DATA_ACK){
	}
	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);//enable TWI and ACK
	while(!(TWCR & (1<<TWINT)));
	indoor2 = TWDR;//assign second byte read to variable
	if((TWSR & 0xF8) != TW_MR_DATA_ACK){
	}
	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWSTO);//stop transmission
}

int temp2int()
{
	int tempcent = 0;
	if((indoor1 & 0x40)!=0x00)
		tempcent= tempcent+128;
	if((indoor1 & 0x20)!=0x00)
		tempcent= tempcent+64;
	if((indoor1 & 0x10)!=0x00)
		tempcent= tempcent+32;
	if((indoor1 & 0x08)!=0x00)
		tempcent= tempcent+16;
	if((indoor1 & 0x04)!=0x00)
		tempcent= tempcent+8;
	if((indoor1 & 0x02)!=0x00)
		tempcent= tempcent+4;
	if((indoor1 & 0x01)!=0x00)
		tempcent= tempcent+2;
	if((indoor2 & 0x80)!=0x00)
		tempcent++;
	return(tempcent);
}

void temp2lcd(int temp1,int temp2)
{
	char null[65], null2[65];	
	cursor_home();		
	itoa(temp1,null,10);	
	home_line2();
	string2lcd("In:");
	string2lcd(null);	
	itoa(temp2,null2,10);	
	//home_line2();	
	string2lcd("  Out:");
	string2lcd(null2);	
}

//**************************************************************
//                             uart_init
//
//RXD0 is PORT E bit 0
//TXD0 is PORT E bit 1
//Jumpers J14 and J16 (mega128.1) OR
//Jumpers J7 and J9 (mega128.2)
//must be in place for the MAX232 chip to get data.
//
void uart_init(){
//rx and tx enable, 8 bit characters
   UCSR0B |= (1<<RXEN0) | (1<<TXEN0);
//async operation, no parity, one stop bit, 8-bit characters
   UCSR0C |= (1<<UCSZ01) | (1<<UCSZ00);
//set to 9600 baud
   UBRR0H=0x00;
   UBRR0L=0x33;
}
//**************************************************************

//**************************************************************
//                         uart_getc
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
   uint16_t timer = 0;
   while (!(UCSR0A & (1<<RXC0))) {
     timer++;
     if(timer >= 16000) return 0;
   } // Wait for byte to arrive
   return UDR0;
}
//**************************************************************


/***** interrupt service routine *****/ 
ISR(TIMER0_OVF_vect) {
   count++;
   if((count % 128) == 0){
      if(alarmset!=1){
	colon ^= 0x01;}
      else if(alarmset==1){
	colon = 0x01;}
      if(snooze==1 && alarm_status==1){
	snooze1++;}
      sec++;}         //increment seconds
   if(count % 8 == 0) {
    //for note duration (64th notes) 
    beat++;
  }           
  }//SIG_OVERFLOW0
//ISR

//********** *************************************************************************
uint8_t main()
{
//timer counter 0 setup, running off i/o clock
  TCCR0 = 0x01;       //normal mode, no prescaling
  TCCR2 = (1<<FOC2)|(1<<COM21)|(1<<COM20)|(1<<WGM20)|(1<<CS00); //phase correct PWM
  TCNT2=0x00; //set timer initial value
  //OCR2=0xFF; //The output compare adjusting duty cycle of pwm
  ASSR  |= (1<<AS0);       //use ext oscillator
  TIMSK = (1<<TOIE0); //allow interrupts on overflow
  sei(); //enable global interrupt
  spi_init(); //initialize spi
  DDRB  = 0xF7; //set port bit 3 B as input, rest output
  spi_send(0x00);
  lcd_init();
  clear_display();
                                               
  DDRF &= ~(0x80); //port F bit 7 is ADC input
  PORTF &= ~(0x80); //port F bit 7 pullups are off
  //use AVCC as vref, right justify, single-ended PORTF bit 7
  ADMUX |= (1<<REFS0) | (1<<REFS1) | (1<<MUX2) | (1<<MUX1) | (1<<MUX0);
  //ADC enabled, don't start yet, single shot mode, run at 125khz
  ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
  
  DDRD = 0xFF;
  PORTD = 0xFF;
  music_init();
  
  twi_init();
  rd_temp();
  
  uart_init();
 
  while(1){
    //make PORTA an input port with pullups 
    DDRA = 0x00;
    PORTA = 0xFF;
    //enable tristate buffer for pushbutton switches
    PORTB = 0x5F;
    
    //time/alarm settings
    time = (hour * 100)+min;
    alarm = (ahour * 100)+amin;
    
    if(alarm_status==0){
      snooze=0;}
    if((time==alarm && pm==alarm_pm && snooze==0 && alarm_status==1)||(snooze1==snoozeseconds && alarm_status==1)){
      alarm_on=1;}
    else if(time!=alarm || snooze==1 || alarm_status==0){
      alarm_on=0;}
    if(snooze==1 && snooze1==snooze2 && alarm_status==1){
      alarm_on=1;
      button3=0;
      snooze=0;}
    if(alarm_on==1 && alarm_status==1){
      if(musicflag==1){
	music_on();}
      musicflag=0;
      cursor_home();
      string2lcd("Wake Up!!");}
    else if(alarm_status==1){
      music_off();
      musicflag=1;
      cursor_home();
      string2lcd("Alarm On ");}
    else if(alarm_on==0 && alarm_status==0){
      music_off();
      musicflag=1;
      cursor_home();
      string2lcd("Alarm Off");}
    
    //main core
    chkbuttons();
    spi_send(bargraph);
    printscrn();
    dimming();
    if(button1==1 || button2==1){
      encoder_ping();}
      
    //displays the appropriate setting(time or alarm)
    if (snooze==1){
      disp_value = snoozeseconds-snooze1;}
    else if (alarmset==0){
      disp_value = time;}
    else if (alarmset==1){
      disp_value = alarm;}
  
    //control time functions in the forward direction
    if(sec==60){
      min++;
      sec=0;}//if
    if(min==60){
      if(hour==11){
	pm^=0x01;}
      if(timeset==0){
      hour++;}
      min=0;}//if
    if(hour==13){
      hour=1;}//if
      
    //temp functions  
    rd_temp();  
    int i=temp2int();//decode values of temperature;
    int j=uart_getc();
    temp2lcd(i,j);
  }//while
}//main
 
